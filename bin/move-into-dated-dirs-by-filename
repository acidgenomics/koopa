#!/usr/bin/env bash

KOOPA_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." \
    >/dev/null 2>&1 && pwd -P)"
# shellcheck source=/dev/null
source "${KOOPA_HOME}/shell/bash/include/header.sh"



# Usage                                                                     {{{1
# ==============================================================================

usage() {
cat << EOF
$(_koopa_help_header)
    files...

Move files into dated subdirectories by file name.

required positional arguments:
    ... File paths.
        Assuming we're matching inside current working directory.
        Supports glob matching, but try to keep it simple.

$(_koopa_help_args)

details:
    Useful for organizing photos, scans, and videos.

see also:
    https://unix.stackexchange.com/questions/9496

examples:
    - 20190101_010101_0001.mov
    - 2019-01-01-01-01-01.pdf

note:
    Bash script.
    Updated 2019-10-15.
EOF
}

_koopa_help "$@"



# Script                                                                    {{{1
# ==============================================================================

if [[ -z "${1:-}" ]]
then
    >&2 printf "Error: No files were specified.\n"
    exit 1
fi

grep_array=(
    '^([0-9]{4})'
    '([-_])?'
    '([0-9]{2})'
    '([-_])?'
    '([0-9]{2})'
    '([-_])?'
    '([0-9]{2})'
    '([-_])?'
    '([0-9]{2})'
    '([-_])?'
    '([0-9]{2})'
    '(.+)$'
)
grep_string="$(printf %s "${grep_array[@]}" $'\n')"

for file in "$@"
do
    # Using Bash built-in regular expressions here.
    if [[ "$file" =~ $grep_string ]]
    then
        year="${BASH_REMATCH[1]}"
        month="${BASH_REMATCH[3]}"
        day="${BASH_REMATCH[5]}"
        subdir="${year}/${month}/${day}"
        mkdir --parents --verbose "$subdir"
        mv --no-clobber --verbose "$file" "$subdir"
    else
        >&2 printf "Error: '%s' file does not contain date in name.\n" "$file"
        >&2 printf "grep string: '%s'\n" "$grep_string"
        exit 1
    fi
done
