#!/usr/bin/env bash

# shellcheck source=/dev/null
source "$(koopa header bash)"

# Symlink dot file.
# Updated 2019-06-23.

# Note that relative file path in dotfiles repo can be used as input.
# The destination file should be specified without a leading period.



# Usage                                                                     {{{1
# ==============================================================================

usage() {
cat << EOF
usage: dotfile [-h] RELATIVE_PATH [SYMLINK_NAME]

required positional arguments:
    1: relative_path
        Relative file path in dotfiles repo.

optional positional arguments:
    2: symlink_name
        Name of destination symlink (without '.' prefix).

optional arguments:
    -h, --help
        Show this help message and exit.
    -f, --force 
        Force overwrite.
        Applies to symlinks only.
    -p, --private
        Private dot file.
        Currently only works for Mike's configuration.
    -q, --quiet
        Quiet mode. Don't print messages.
EOF
}

[[ -z "$*" ]] && usage && exit



# Parse arguments                                                           {{{1
# ==============================================================================

# Using flags and positional arguments.
# https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f

PARAMS=""

while (("$#"))
do
    case "$1" in
        -f|--force)
            force=1
            shift 1
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -p|--private)
            private=1
            shift 1
            ;;
        -q|--quiet)
            quiet=1
            shift 1
            ;;
        --)
            # End argument parsing.
            shift
            break
            ;;
        --*|-*)
            # Unsupported flags.
            >&2 printf "Error: Invalid flag %s\n" "$1"
            exit 1
            ;;
        *)
            # Preserve positional arguments.
            PARAMS="${PARAMS} ${1}"
            shift
            ;;
    esac
done

# Set positional arguments in their proper place.
eval set -- "$PARAMS"

unset -f usage



# Script                                                                    {{{1
# ==============================================================================

dot_dir="$(koopa config-dir)/dotfiles"

# Private file (experimental).
if [[ "${private:-0}" -eq 1 ]]
then
    dot_dir="${dot_dir}-private"
fi

# Error if the dotfiles directory can't be found.
if [[ ! -d "$dot_dir" ]]
then
    >&2 printf "Error: dotfiles directory missing: '%s'.\n" "$dot_dir"
    exit 1
fi

# Error if the source file can't be found.
source_path="${dot_dir}/${1}"
if [[ ! -f "$source_path" && ! -d "$source_path" ]]
then
    >&2 printf "Error: source missing: '%s'.\n" "$source_path"
    exit 1
fi

# Define optional destination name.
symlink_name="${2:-}"
[[ -z "$symlink_name" ]] && symlink_name="$(basename "$source_path")"

symlink_path="${HOME}/.${symlink_name}"

# Inform the user when nuking a broken symlink.
if [[ -L "$symlink_path" ]] && [[ ! -e "$symlink_path" ]]
then
    printf "Overwriting broken link: '%s'.\n" "$symlink_path"
    rm -f "$symlink_path"
fi

# We're allowing force overwrite of existing symlinks only.
if [[ -L "$symlink_path" ]] &&
    [[ -f "$symlink_path" || -d "$symlink_path" ]] &&
    [[ -z "${force:-}" ]]
then
    [[ -n "${quiet:-}" ]] && exit 0
    >&2 printf "Error: Existing symlink: '%s'.\n" "$symlink_path"
    exit 1
elif [[ ! -L "$symlink_path" ]] && [[ -e "$symlink_path" ]]
then
    >&2 printf "Error: Existing file: '%s'.\n" "$symlink_path"
    exit 1
fi

if [[ -z "${quiet:-}" ]]
then
    printf "Symlinking '%s'.\n" "$(basename "$symlink_path")"
fi

rm -f "$symlink_path"
ln -s "$source_path" "$symlink_path"
