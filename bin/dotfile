#!/usr/bin/env bash
set -Eeuo pipefail

# Add dot file.
# Modified 2019-06-14.

# Note that relative file path in dotfiles repo can be used as input.
# The destination file should be specified without a leading period.



# Parse arguments                                                           {{{1
# ==============================================================================

# Using flags and positional arguments.
# https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f

PARAMS=""

while (("$#"))
do
    case "$1" in
        -f|--force)
            force=1
            shift 1
            ;;
        -h|--help)
            help=1
            shift 1
            ;;
        --) # End argument parsing.
            shift
            break
            ;;
        --*|-*) # Unsupported flags.
            echo "Error: Invalid flag $1" >&2
            exit 1
            ;;
        *) # Preserve positional arguments.
            PARAMS="$PARAMS $1"
            shift
            ;;
    esac
done

# Set positional arguments in their proper place.
eval set -- "$PARAMS"



# Help                                                                      {{{1
# ==============================================================================

if [[ -n "${help:-}" || -z "$*" ]]
then
    echo "Usage: dotfile [-f|--force] repo_relative_path (symlink_name)"
    exit 0
fi



# Script                                                                    {{{1
# ==============================================================================

dot_dir="${KOOPA_DIR}/dotfiles"
if [[ ! -d "$dot_dir" ]]
then
    >&2 printf "Error: %s missing.\n" "$dot_dir"
    exit 1
fi

source_path="${dot_dir}/${1}"
if [[ ! -f "$source_path" && ! -d "$source_path" ]]
then
    >&2 printf "Error: %s missing.\n" "$source_path"
    exit 1
fi

symlink_name="${2:-}"
[[ -z "$symlink_name" ]] && symlink_name="$(basename "$source_path")"

symlink_path="${HOME}/.${symlink_name}"
if [[ -L "$symlink_path" && -f "$symlink_path" && -z "${force:-}" ]]
then
    # Early return if dot file already exists.
    exit 0
elif [[ ! -L "$symlink_path" && -f "$symlink_path" ]]
then
    # Error if dot file exists but is not a symlink.
    >&2 printf "Error: '%s' exists, and is not a symlink." "$symlink_path"
    exit 1
fi

printf "Symlinking '%s'.\n" "$(basename $symlink_path)"
rm -f "$symlink_path"
ln -s "$source_path" "$symlink_path"
