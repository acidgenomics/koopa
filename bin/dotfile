#!/usr/bin/env bash
set -Eeuo pipefail

# Add dot file.
# Modified 2019-06-14.

# Note that relative file path in dotfiles repo can be used as input.
# The destination file should be specified without a leading period.



# Parse arguments                                                           {{{1
# ==============================================================================

# Using flags and positional arguments.
# https://medium.com/@Drew_Stokes/bash-argument-parsing-54f3b81a6a8f

PARAMS=""

while (("$#"))
do
    case "$1" in
        -f|--force)
            force=1
            shift 1
            ;;
        -h|--help)
            help=1
            shift 1
            ;;
        -q|--quiet)
            quiet=1
            shift 1
            ;;
        --) # End argument parsing.
            shift
            break
            ;;
        --*|-*) # Unsupported flags.
            echo "Error: Invalid flag $1" >&2
            exit 1
            ;;
        *) # Preserve positional arguments.
            PARAMS="$PARAMS $1"
            shift
            ;;
    esac
done

# Set positional arguments in their proper place.
eval set -- "$PARAMS"



# Help                                                                      {{{1
# ==============================================================================

if [[ -n "${help:-}" || -z "$*" ]]
then

cat << EOF
    Usage: dotfile relative_path (symlink_name)

    relative_path: Relative file path in dotfiles repo.
    symlink_name: Name of destination symlink (without '.' prefix).

    Flags:
        -f, --force  Force overwrite. Applies to symlinks only.
        -h, --help   Help.
        -q, --quiet  Quiet mode. Don't print messages.

EOF
    exit 0
fi



# Script                                                                    {{{1
# ==============================================================================

dot_dir="${KOOPA_DIR}/dotfiles"
if [[ ! -d "$dot_dir" ]]
then
    >&2 printf "Error: %s missing.\n" "$dot_dir"
    exit 1
fi

source_path="${dot_dir}/${1}"
if [[ ! -f "$source_path" && ! -d "$source_path" ]]
then
    >&2 printf "Error: %s missing.\n" "$source_path"
    exit 1
fi

symlink_name="${2:-}"
[[ -z "$symlink_name" ]] && symlink_name="$(basename "$source_path")"
symlink_path="${HOME}/.${symlink_name}"

# We're allowing force overwrite of symlinks only.
if [[ -L "$symlink_path" ]] && \
    [[ -f "$symlink_path" || -d "$symlink_path" ]] && \
    [[ -z "${force:-}" ]]
then
    [[ -n "${quiet:-}" ]] && exit 0
    >&2 printf "Error: Existing symlink.\n%s\n" "$symlink_path"
    exit 1
elif [[ ! -L "$symlink_path" ]] && \
    [[ -f "$symlink_path" || -d "$symlink_path" ]]
then
    >&2 printf "Error: Existing file.\n%s\n" "$symlink_path"
    exit 1
fi

if [[ -n "${quiet:-}" ]]
then
    printf "Symlinking '%s'.\n" "$(basename $symlink_path)"
fi
rm -f "$symlink_path"
ln -s "$source_path" "$symlink_path"
