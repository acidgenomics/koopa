#!/usr/bin/env bash

KOOPA_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." \
    >/dev/null 2>&1 && pwd -P)"
# shellcheck source=/dev/null
source "${KOOPA_HOME}/shell/bash/include/header.sh"



# Usage                                                                     {{{1
# ==============================================================================

usage() {
cat << EOF
$(_koopa_help_header)
    [--rename]
    string|file...

Make syntactically valid names.

required positional arguments:
    ... Character strings or file names to sanitize.

optional arguments:
    --rename
        Rename input files.
        Assumes we're renaming files in current working directory, but also
            supports explicit and/or mixed file paths. Doesn't work recursively.
        Disabled by default.

$(_koopa_help_args)

details:
    Runs in string mode by default.
    File rename mode can be enabled by setting '--rename' flag.
    If you need to standardize file names prefixed with a number, consider using
        kebab or snake case functions instead, which support '--prefix' flag.

see also:
    - 'syntactic::makeNames()' in R. Sanitizes using underscores (good).
    - 'make.names()' in R (the base version). Sanitizes using dots (bad).

examples:
    make-names "hello world" "foo bar"
    ## hello_world foo_bar

    make-names --files 1-control-A.fastq.gz
    ## ./X1_control_A.fastq.gz

note:
    Bash script that calls Rscript internally.
    Requires the syntactic package to be installed.
    Updated 2019-10-09.
EOF
}

_koopa_help "$@"



# Arguments                                                                 {{{1
# ==============================================================================

rename=0

POSITIONAL=()
while (("$#"))
do
    case "$1" in
        --rename)
            rename=1
            shift 1
            ;;
        --)
            shift 1
            break
            ;;
        --*|-*)
            >&2 printf "Error: Invalid argument: '%s'\n" "$1"
            exit 1
            ;;
        *)
            POSITIONAL+=("$1")
            shift 1
            ;;
    esac
done
set -- "${POSITIONAL[@]}"



# Script                                                                    {{{1
# ==============================================================================

script_name="$(basename "$0")"

# Rename file mode                                                          {{{2
# ------------------------------------------------------------------------------

if [[ "$rename" -eq 1 ]]
then
    source_arr=("$@")
    source_dn_arr=()
    source_bn_arr=()
    source_ext_arr=()
    for x in "${source_arr[@]}"
    do
        source_dn_arr+=("$(dirname "$x")")
        source_bn_arr+=("$(_koopa_basename_sans_ext2 "$x")")
        source_ext_arr+=("$(_koopa_file_ext2 "$x")")
    done
    target_arr=()
    target_dn_arr=("${source_dn_arr[@]}")
    target_bn_arr=("${source_bn_arr[@]}")
    target_ext_arr=("${source_ext_arr[@]}")
    # Sanitize basenames.
    read -r -a target_bn_arr <<< "$("$script_name" "${target_bn_arr[@]}")"
    for i in "${!source_arr[@]}"
    do
        target_dn="${target_dn_arr[$i]}"
        target_bn="${target_bn_arr[$i]}"
        target_ext="${target_ext_arr[$i]}"
        # Add back leading period to extension, if necessary.
        # Note that this step supports files without an extension.
        if [[ -n "$target_ext" ]]
        then
            target_ext=".${target_ext}"
        fi
        target_arr+=( \
            "$(printf "%s/%s%s" "$target_dn" "$target_bn" "$target_ext")" \
        )
    done
    for i in "${!source_arr[@]}"
    do
        if _koopa_is_darwin
        then
            flags=("-v")
        else
            flags=("--no-target-directory" "--verbose")
        fi
        mv "${flags[@]}" "${source_arr[$i]}" "${target_arr[$i]}"
    done
    exit 0
fi

# String mode                                                               {{{2
# ------------------------------------------------------------------------------

object="$(_koopa_array_to_r_vector "$@")"
Rscript -e " \
    cat(
        syntactic::makeNames(${object}),
        '\n',
        sep = ' '
    ) \
"
