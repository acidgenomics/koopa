#!/usr/bin/env bash
set -Eeu -o pipefail

# shellcheck source=/dev/null
source "$(koopa header bash)"

source_dir="."
target_dir="."
prefix="lanepool"



# Usage                                                                     {{{1
# ==============================================================================

usage() {
cat << EOF
usage: fastq-lanepool [--help|-h] [--source_dir="${source_dir}"]
    [--target_dir="${target_dir}"] [--prefix="${prefix}"]

Pool (concatenate) lane-split FASTQ files.

required arguments, with defaults:
    --source-dir
        Source lane-split FASTQ directory path.
        Defaults to '${source_dir}'.
    --target-dir
        Target concatenated FASTQ director path.
        Defaults to '${target_dir}'.
    --prefix
        Name prefix for concatenated FASTQ files.
        Defaults to '${prefix}'.

details:
    Matches against '_L00[1-9]_' lane pattern internally.
    Defaults to input and output in current working directory.
    Supports both compressed (*.fastq.gz) and decompressed (.fastq) FASTQ files.

note:
    Bash script.
    Updated 2019-09-21.

examples:
    # Input (2 paired-end, lane-split samples):
    ls *.fastq.gz
    # > sample1_L001_R1.fastq.gz
    # > sample1_L002_R1.fastq.gz
    # > sample1_L003_R1.fastq.gz
    # > sample1_L004_R1.fastq.gz
    # > sample1_L001_R2.fastq.gz
    # > sample1_L002_R2.fastq.gz
    # > sample1_L003_R2.fastq.gz
    # > sample1_L004_R2.fastq.gz
    # > sample2_L001_R1.fastq.gz
    # > sample2_L002_R1.fastq.gz
    # > sample2_L003_R1.fastq.gz
    # > sample2_L004_R1.fastq.gz
    # > sample2_L001_R2.fastq.gz
    # > sample2_L002_R2.fastq.gz
    # > sample2_L003_R2.fastq.gz
    # > sample2_L004_R2.fastq.gz

    # Pool the samples.
    fastq-lanepool --source-dir="." --target-dir="." --prefix="lanepool"

    # Output:
    # > lanepool_sample1_R1.fastq.gz
    # > lanepool_sample1_R2.fastq.gz
    # > lanepool_sample2_R1.fastq.gz
    # > lanepool_sample2_R2.fastq.gz
EOF
}



# Parse arguments                                                           {{{1
# ==============================================================================

# https://stackoverflow.com/questions/192249

for i in "$@"
do
    case "$i" in
        --help|-h)
            usage
            exit 0
            ;;
        --prefix=*)
            prefix="${i#*=}"
            shift
            ;;
        --source-dir=*)
            source_dir="${i#*=}"
            shift
            ;;
        --target-dir=*)
            target_dir="${i#*=}"
            shift
            ;;
        *)
            # Invalid argument.
            >&2 printf "Error: Invalid arg: '%s'\n" "$i"
            exit 1
            ;;
    esac
done

# Handle trailing directory '/' automatically.
source_dir="${source_dir//\//}"
target_dir="${target_dir//\//}"



# Script                                                                    {{{1
# ==============================================================================

# Create the target directory automatically, if necessary.
mkdir -p "$target_dir"

# Put unique samples into an array and loop.
array=()
while IFS=  read -r -d $'\0'; do
    array+=("$REPLY")
done < <(find "$source_dir" -maxdepth 1 -name "*_L001_*.fastq*" -print0)

# Error if file array is empty.
if [[ "${#array[@]}" -eq 0 ]]
then
    >&2 printf "Error: No lane-split FASTQ files detected.\n"
    exit 1
fi

basenames=()
for i in "${array[@]}"
do
    basenames+=("$(basename "$i")")
done

head=()
for i in "${basenames[@]}"
do
    i="${i//_L001_*/}"
    head+=("$i")
done

tail=()
for i in "${basenames[@]}"
do
    i="${i//*_L001_/}"
    tail+=("$i")
done

out=()
for i in "${basenames[@]}"
do
    i="${i//_L001/}"
    i="${target_dir}/${prefix}_${i}"
    out+=("$i")
done

# Loop across the array indices, similar to 'mapply()' approach in R.
for i in "${!out[@]}"
do
    cat "${source_dir}/${head[i]}_L00"[1-9]"_${tail[i]}" > "${out[i]}"
done
