#!/usr/bin/env bash

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)"
# shellcheck source=/dev/null
source "${script_dir}/../shell/bash/include/header.sh"

source_dir='.'
target_dir='.'
prefix='lanepool'

while (("$#"))
do
    case "$1" in
        --prefix=*)
            prefix="${1#*=}"
            shift 1
            ;;
        --prefix)
            prefix="$2"
            shift 2
            ;;
        --source-dir=*)
            source_dir="${1#*=}"
            shift 1
            ;;
        --source-dir)
            source_dir="$2"
            shift 2
            ;;
        --target-dir=*)
            target_dir="${1#*=}"
            shift 1
            ;;
        --target-dir)
            target_dir="$2"
            shift 2
            ;;
        *)
            koopa::invalid_arg "$1"
            ;;
    esac
done

source_dir="$(koopa::strip_trailing_slash "$source_dir")"
target_dir="$(koopa::strip_trailing_slash "$target_dir")"

# Pipe GNU find into array.
readarray -t array <<< "$( \
    find "$source_dir" \
        -maxdepth 1 \
        -mindepth 1 \
        -type f \
        -iname "*_L001_*.fastq*" \
        -print \
    | sort \
)"

# Error if file array is empty.
if [[ "${#array[@]}" -eq 0 ]]
then
    koopa::stop 'No lane-split FASTQ files detected.'
fi

# Create the target directory automatically, if necessary.
mkdir -pv "$target_dir"

basenames=()
for i in "${array[@]}"
do
    basenames+=("$(basename "$i")")
done

head=()
for i in "${basenames[@]}"
do
    i="${i//_L001_*/}"
    head+=("$i")
done

tail=()
for i in "${basenames[@]}"
do
    i="${i//*_L001_/}"
    tail+=("$i")
done

out=()
for i in "${basenames[@]}"
do
    i="${i//_L001/}"
    i="${target_dir}/${prefix}_${i}"
    out+=("$i")
done

# Loop across the array indices, similar to 'mapply()' approach in R.
for i in "${!out[@]}"
do
    cat "${source_dir}/${head[i]}_L00"[1-9]"_${tail[i]}" > "${out[i]}"
done
