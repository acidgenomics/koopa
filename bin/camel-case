#!/usr/bin/env bash

KOOPA_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." \
    >/dev/null 2>&1 && pwd -P)"
# shellcheck source=/dev/null
source "${KOOPA_HOME}/shell/bash/include/header.sh"



# Usage                                                                     {{{1
# ==============================================================================

usage() {
cat << EOF
$(_koopa_help_header)
    [--files] [--prefix] [--rename] [--strict]
    string...

Convert input into camel case.

required positional arguments:
    ... Character strings to sanitize.

optional arguments:
    --files
        File name mode. Preserves file extensions. In this case, we're
        preserving anything after the first '.' in the file name. This makes
        supporting complex file names (e.g. '*.fastq.gz') easier. Note that this
        flag on its own does not rename input.
    --prefix
        Include "x" prefix for names that are syntactically invalid in R.
        This includes files that begin with a number.
    --rename
        Rename input files. Sets '--files' flag automatically. Assumes we're
        renaming files in current working directory but also supports explicit
        and/or mixed file paths.
    --strict
        Enforce strict camel syntax. Applies primarily to acronyms.
        For example, "ID" becomes "Id".
        Disabled by default.

$(_koopa_help_args)

details:
    Note that strings beginning with a number will be prefixed with 'x'.

see also:
    - 'syntactic::camelCase()' in R.
    - make-names

examples:
    camel-case "hello world" "foo bar"
    ## helloWorld fooBar

    camel-case --strict "gene ID"
    ## geneId

    camel-case --files "foo-bar.fastq.gz"
    ## ./fooBar.fastq.gz

    camel-case --files 1-control-A.fastq.gz
    ## ./x1ControlA.fastq.gz

note:
    Bash script that calls Rscript internally.
    Requires the syntactic package to be installed.
    Updated 2019-10-07.
EOF
}

_koopa_help "$@"



# Arguments                                                                 {{{1
# ==============================================================================

files=0
prefix="FALSE"
rename=0
strict="FALSE"

POSITIONAL=()
while (("$#"))
do
    case "$1" in
        --files)
            files=1
            shift 1
            ;;
        --prefix)
            prefix="TRUE"
            shift 1
            ;;
        --rename)
            files=1
            rename=1
            shift 1
            ;;
        --strict)
            strict="TRUE"
            shift 1
            ;;
        --)
            shift 1
            break
            ;;
        --*|-*)
            >&2 printf "Error: Invalid argument: '%s'\n" "$1"
            exit 1
            ;;
        *)
            POSITIONAL+=("$1")
            shift 1
            ;;
    esac
done
set -- "${POSITIONAL[@]}"



# Script                                                                    {{{1
# ==============================================================================

# String mode                                                               {{{2
# ------------------------------------------------------------------------------

if [[ "$files" -eq 0 ]]
then
    object="$(_koopa_array_to_r_vector "$@")"
    Rscript -e " \
        cat(
            syntactic::camelCase(
                object = ${object},
                strict = ${strict},
                prefix = ${prefix}
            ),
            '\n',
            sep = ' '
        ) \
    "
    exit 0
fi

# File mode                                                                 {{{2
# ------------------------------------------------------------------------------

if [[ "$files" -eq 1 ]]
then
    source=("$@")
    dirname=()
    basename=()
    ext=()

    # Mapply-style approach, looping across the file input.
    for x in "${source[@]}"
    do
        dirname+=("$(dirname "$x")")
        basename+=("$(_koopa_basename_sans_ext2 "$x")")
        ext+=("$(_koopa_file_ext2 "$x")")
    done

    # Sanitize the base name.
    camel="$(camel-case "${basename[@]}")"
    # SC2206: Split robustly with mapfile or read -a.
    read -r -a camel <<< "$camel"

    target=()
    for i in "${!source[@]}"
    do
        target+=( \
            "$(printf "%s/%s.%s" \
                "${dirname[$i]}" "${camel[$i]}" "${ext[$i]}" \
            )" \
        )
    done
fi

# Rename mode                                                               {{{2
# ------------------------------------------------------------------------------

if [[ "$rename" -eq 1 ]]
then
    for i in "${!source[@]}"
    do
        mv -v "${source[$i]}" "${target[$i]}"
    done
else
    echo "${target[@]}"
fi

