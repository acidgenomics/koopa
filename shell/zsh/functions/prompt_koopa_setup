#!/usr/bin/env zsh

# Koopa ZSH prompt
# Updated 2019-08-17.

# Modified version of Pure, by Sindre Sorhus.
# https://github.com/sindresorhus/koopa



# Debugging:
# > prompt_koopa_system_report
# > typeset prompt_koopa_state



# prompt:
# - %F     => color dict
# - %f     => reset color
# - %~     => current path
# - %*     => time
# - %n     => username
# - %m     => shortname host
# - %(?..) => prompt conditional - %(condition.true.false)
#
# terminal codes:
# - \e7   => save cursor position
# - \e[2A => move cursor 2 lines up
# - \e[1G => go to position 1 in terminal
# - \e8   => restore cursor position
# - \e[K  => clears everything after the cursor on the current line
# - \e[2K => clear everything on the current line



# Turns seconds into human readable time.
# 165392 => 1d 21h 56m 32s
# https://github.com/sindresorhus/pretty-time-zsh
prompt_koopa_human_time_to_var() {
    local human total_seconds=$1 var=$2
    local days=$(( total_seconds / 60 / 60 / 24 ))
    local hours=$(( total_seconds / 60 / 60 % 24 ))
    local minutes=$(( total_seconds / 60 % 60 ))
    local seconds=$(( total_seconds % 60 ))
    (( days > 0 )) && human+="${days}d "
    (( hours > 0 )) && human+="${hours}h "
    (( minutes > 0 )) && human+="${minutes}m "
    human+="${seconds}s"
    # Store human readable time in a variable as specified by the caller.
    typeset -g "${var}"="${human}"
}



# Stores (into prompt_koopa_cmd_exec_time) the execution time of the last command
# if set threshold was exceeded.
prompt_koopa_check_cmd_exec_time() {
    integer elapsed
    (( elapsed = EPOCHSECONDS - ${prompt_koopa_cmd_timestamp:-$EPOCHSECONDS} ))
    typeset -g prompt_koopa_cmd_exec_time=
    (( elapsed > ${PURE_CMD_MAX_EXEC_TIME:-5} )) && {
        prompt_koopa_human_time_to_var $elapsed "prompt_koopa_cmd_exec_time"
    }
}


prompt_koopa_preexec() {
    typeset -g prompt_koopa_cmd_timestamp="$EPOCHSECONDS"

    # Disallow Python virtualenv from updating the prompt. Set it to 12 if
    # untouched by the user to indicate that koopa modified it. Here we use
    # the magic number 12, same as in `psvar`.
    export VIRTUAL_ENV_DISABLE_PROMPT="${VIRTUAL_ENV_DISABLE_PROMPT:-12}"
}



# Change the colors if their value are different from the current ones.
prompt_koopa_set_colors() {
    local color_temp key value
    for key value in ${(kv)prompt_koopa_colors}; do
        zstyle -t ":prompt:koopa:$key" color "$value"
        case $? in
            1) # The current style is different from the one from zstyle.
                zstyle -s ":prompt:koopa:$key" color color_temp
                prompt_koopa_colors[$key]=$color_temp ;;
            2) # No style is defined.
                prompt_koopa_colors[$key]=$prompt_koopa_colors_default[$key] ;;
        esac
    done
}



prompt_koopa_preprompt_render() {
    setopt localoptions noshwordsplit

    # Initialize the preprompt array.
    local -a preprompt_parts

    # Set the path.
    preprompt_parts+=('%F{${prompt_koopa_colors[path]}}%~%f')

    # Username and machine, if applicable.
    [[ -n $prompt_koopa_state[username] ]] && preprompt_parts+=($prompt_koopa_state[username])
    # Execution time.
    [[ -n $prompt_koopa_cmd_exec_time ]] && preprompt_parts+=('%F{$prompt_koopa_colors[execution_time]}${prompt_koopa_cmd_exec_time}%f')

    local cleaned_ps1=$PROMPT
    local -H MATCH MBEGIN MEND
    if [[ $PROMPT = *$prompt_newline* ]]; then
        # Remove everything from the prompt until the newline. This
        # removes the preprompt and only the original PROMPT remains.
        cleaned_ps1=${PROMPT##*${prompt_newline}}
    fi
    unset MATCH MBEGIN MEND

    # Construct the new prompt with a clean preprompt.
    local -ah ps1
    ps1=(
        ${(j. .)preprompt_parts}  # Join parts, space separated.
        $prompt_newline           # Separate preprompt and prompt.
        $cleaned_ps1
    )

    PROMPT="${(j..)ps1}"

    # Expand the prompt for future comparision.
    local expanded_prompt
    expanded_prompt="${(S%%)PROMPT}"

    if [[ $1 == precmd ]]; then
        # Initial newline, for spaciousness.
        print
    elif [[ $prompt_koopa_last_prompt != $expanded_prompt ]]; then
        # Redraw the prompt.
        prompt_koopa_reset_prompt
    fi

    typeset -g prompt_koopa_last_prompt=$expanded_prompt
}



prompt_koopa_precmd() {
    # Check execution time and store it in a variable.
    prompt_koopa_check_cmd_exec_time
    unset prompt_koopa_cmd_timestamp

    # Modify the colors if some have changed..
    prompt_koopa_set_colors

    # Check if we should display the virtual env. We use a sufficiently high
    # index of psvar (12) here to avoid collisions with user defined entries.
    psvar[12]=
    # Check if a Conda environment is active and display its name.
    if [[ -n $CONDA_DEFAULT_ENV ]]; then
        psvar[12]="${CONDA_DEFAULT_ENV//[$'\t\r\n']}"
    fi
    # When VIRTUAL_ENV_DISABLE_PROMPT is empty, it was unset by the user and
    # Pure should take back control.
    if [[ -n $VIRTUAL_ENV ]] && [[ -z $VIRTUAL_ENV_DISABLE_PROMPT || $VIRTUAL_ENV_DISABLE_PROMPT = 12 ]]; then
        psvar[12]="${VIRTUAL_ENV:t}"
        export VIRTUAL_ENV_DISABLE_PROMPT=12
    fi

    # Make sure VIM prompt is reset.
    prompt_koopa_reset_prompt_symbol

    # Print the preprompt.
    prompt_koopa_preprompt_render "precmd"

    if [[ -n $ZSH_THEME ]]
    then
        >&2 print "WARNING: Oh My Zsh theme is enabled. Disabling."
        unset ZSH_THEME
    fi
}



prompt_koopa_reset_prompt() {
    if [[ $CONTEXT == cont ]]; then
        # When the context is "cont", PS2 is active and calling
        # reset-prompt will have no effect on PS1, but it will
        # reset the execution context (%_) of PS2 which we don't
        # want. Unfortunately, we can't save the output of "%_"
        # either because it is only ever rendered as part of the
        # prompt, expanding in-place won't work.
        return
    fi

    zle && zle .reset-prompt
}



prompt_koopa_reset_prompt_symbol() {
    prompt_koopa_state[prompt]=${PURE_PROMPT_SYMBOL:-❯}
}



prompt_koopa_state_setup() {
    setopt localoptions noshwordsplit

    # Check SSH_CONNECTION and the current state.
    local ssh_connection=${SSH_CONNECTION:-$PROMPT_PURE_SSH_CONNECTION}
    local username hostname
    if [[ -z $ssh_connection ]] && (( $+commands[who] )); then
        # When changing user on a remote system, the $SSH_CONNECTION
        # environment variable can be lost. Attempt detection via `who`.
        local who_out
        who_out=$(who -m 2>/dev/null)
        if (( $? )); then
            # Who am I not supported, fallback to plain who.
            local -a who_in
            who_in=( ${(f)"$(who 2>/dev/null)"} )
            who_out="${(M)who_in:#*[[:space:]]${TTY#/dev/}[[:space:]]*}"
        fi

        local reIPv6='(([0-9a-fA-F]+:)|:){2,}[0-9a-fA-F]+'  # Simplified, only checks partial pattern.
        local reIPv4='([0-9]{1,3}\.){3}[0-9]+'   # Simplified, allows invalid ranges.
        # Here we assume two non-consecutive periods represents a
        # hostname. This matches `foo.bar.baz`, but not `foo.bar`.
        local reHostname='([.][^. ]+){2}'

        # Usually the remote address is surrounded by parenthesis, but
        # not on all systems (e.g. busybox).
        local -H MATCH MBEGIN MEND
        if [[ $who_out =~ "\(?($reIPv4|$reIPv6|$reHostname)\)?\$" ]]; then
            ssh_connection=$MATCH

            # Export variable to allow detection propagation inside
            # shells spawned by this one (e.g. tmux does not always
            # inherit the same tty, which breaks detection).
            export PROMPT_PURE_SSH_CONNECTION=$ssh_connection
        fi
        unset MATCH MBEGIN MEND
    fi

    hostname='%F{$prompt_koopa_colors[host]}@%m%f'
    # Show `username@host` if logged in through SSH.
    [[ -n $ssh_connection ]] && username='%F{$prompt_koopa_colors[user]}%n%f'"$hostname"

    # Show `username@host` if root, with username in default color.
    [[ $UID -eq 0 ]] && username='%F{$prompt_koopa_colors[user:root]}%n%f'"$hostname"

    typeset -gA prompt_koopa_state
    prompt_koopa_state[version]="1.10.3"
    prompt_koopa_state+=(
        username "$username"
        prompt   "${PURE_PROMPT_SYMBOL:-❯}"
    )
}



# Updated 2019-08-17.
prompt_koopa_system_report() {
    setopt localoptions noshwordsplit

    print - "- koopa state:"
    for k v in "${(@kv)prompt_koopa_state}"
    do
        print - "\t- $k: \`${(q)v}\`"
    done
    
    print - "- Virtualenv: \`$(typeset -p VIRTUAL_ENV_DISABLE_PROMPT)\`"
    print - "- Prompt: \`$(typeset -p PROMPT)\`"

    local ohmyzsh=0
    typeset -la frameworks
    (( $+ANTIBODY_HOME )) && frameworks+=("Antibody")
    (( $+ADOTDIR )) && frameworks+=("Antigen")
    (( $+ANTIGEN_HS_HOME )) && frameworks+=("Antigen-hs")
    (( $+functions[upgrade_oh_my_zsh] )) && {
        ohmyzsh=1
        frameworks+=("Oh My Zsh")
    }
    (( $+ZPREZTODIR )) && frameworks+=("Prezto")
    (( $+ZPLUG_ROOT )) && frameworks+=("Zplug")
    (( $+ZPLGM )) && frameworks+=("Zplugin")

    (( $#frameworks == 0 )) && frameworks+=("None")
    print - "- Detected frameworks: ${(j:, :)frameworks}"

    if (( ohmyzsh ))
    then
        print - "\t- Oh My Zsh:"
        print - "\t\t- Plugins: ${(j:, :)plugins}"
    fi
}











prompt_koopa_setup() {
    # Prevent percentage showing up if output doesn't end with a newline.
    export PROMPT_EOL_MARK=''

    prompt_opts=(subst percent)

    if [[ -z $prompt_newline ]]; then
        # This variable needs to be set, usually set by promptinit.
        typeset -g prompt_newline=$'\n%{\r%}'
    fi

    zmodload zsh/datetime
    zmodload zsh/zle
    zmodload zsh/parameter
    zmodload zsh/zutil
    
    # Set the colors.
    typeset -gA prompt_koopa_colors_default prompt_koopa_colors
    prompt_koopa_colors_default=(
        execution_time       yellow
        git:arrow            cyan
        git:branch           242
        git:branch:cached    red
        host                 242
        path                 blue
        prompt:error         red
        prompt:success       magenta
        user                 242
        user:root            default
        virtualenv           242
    )
    prompt_koopa_colors=("${(@kv)prompt_koopa_colors_default}")

    add-zsh-hook precmd prompt_koopa_precmd
    add-zsh-hook preexec prompt_koopa_preexec

    prompt_koopa_state_setup

    zle -N prompt_koopa_reset_prompt

    # If a virtualenv is activated, display it in grey.
    PROMPT='%(12V.%F{$prompt_koopa_colors[virtualenv]}%12v%f .)'

    # Prompt turns red if the previous command didn't exit with 0.
    PROMPT+='%(?.%F{$prompt_koopa_colors[prompt:success]}.%F{$prompt_koopa_colors[prompt:error]})${prompt_koopa_state[prompt]}%f '

    # Indicate continuation prompt by ... and use a darker color for it.
    PROMPT2='%F{242}... %(1_.%_ .%_)%f%(?.%F{magenta}.%F{red})${prompt_koopa_state[prompt]}%f '

    # Store prompt expansion symbols for in-place expansion via (%). For
    # some reason it does not work without storing them in a variable first.
    typeset -ga prompt_koopa_debug_depth
    prompt_koopa_debug_depth=('%e' '%N' '%x')

    # Compare is used to check if %N equals %x. When they differ, the main
    # prompt is used to allow displaying both filename and function. When
    # they match, we use the secondary prompt to avoid displaying duplicate
    # information.
    local -A ps4_parts
    ps4_parts=(
        depth     '%F{yellow}${(l:${(%)prompt_koopa_debug_depth[1]}::+:)}%f'
        compare   '${${(%)prompt_koopa_debug_depth[2]}:#${(%)prompt_koopa_debug_depth[3]}}'
        main      '%F{blue}${${(%)prompt_koopa_debug_depth[3]}:t}%f%F{242}:%I%f %F{242}@%f%F{blue}%N%f%F{242}:%i%f'
        secondary '%F{blue}%N%f%F{242}:%i'
        prompt    '%F{242}>%f '
    )
    # Combine the parts with conditional logic. First the `:+` operator is
    # used to replace `compare` either with `main` or an ampty string. Then
    # the `:-` operator is used so that if `compare` becomes an empty
    # string, it is replaced with `secondary`.
    local ps4_symbols='${${'${ps4_parts[compare]}':+"'${ps4_parts[main]}'"}:-"'${ps4_parts[secondary]}'"}'

    # Improve the debug prompt (PS4), show depth by repeating the +-sign and
    # add colors to highlight essential parts like file and function name.
    PROMPT4="${ps4_parts[depth]} ${ps4_symbols}${ps4_parts[prompt]}"

    # Guard against Oh My Zsh themes overriding Pure.
    unset ZSH_THEME
}



prompt_koopa_setup "$@"
